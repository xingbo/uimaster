package org.shaolin.bmdp.persistence.query.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.shaolin.bmdp.datamodel.common.TargetEntityType;
import org.shaolin.bmdp.datamodel.common.VariableCategoryType;
import org.shaolin.bmdp.datamodel.common.VariableType;
import org.shaolin.bmdp.datamodel.rdbdiagram.ConditionFieldMappingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.LinkConditionMappingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.OrderingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.SQLFieldMappingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.SearchConditionMappingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.SearchQueryType;
import org.shaolin.bmdp.datamodel.rdbdiagram.SearchResultMappingType;
import org.shaolin.bmdp.persistence.InvalidSearchQueryException;
import org.shaolin.bmdp.persistence.JoinTableInstance;
import org.shaolin.bmdp.persistence.PersistenceException;
import org.shaolin.bmdp.persistence.PersistentUtil;
import org.shaolin.bmdp.persistence.query.condition.ISearchConditionFilter;
import org.shaolin.bmdp.persistence.query.condition.SearchConditionContext;
import org.shaolin.bmdp.persistence.query.condition.SearchConditionFilterFactory;
import org.shaolin.bmdp.persistence.query.operator.LogicalOperator;
import org.shaolin.bmdp.runtime.VariableUtil;
import org.shaolin.javacc.sql.SQLConstants;
import org.shaolin.javacc.sql.exception.OQLException;
import org.shaolin.javacc.sql.exception.QueryParsingException;

/**
 * the run time object for a search query
 * 
 * SearchQueryGenerator context = new SearchQueryGenerator(query);
				SearchConditionContext scContext = context.getSearchConditionContext();
				String inputParams = scContext.getDefaultInputParams();
				String fromInfo = context.getFromTableInfo();
				String returnType = context.getReturnType();
				String sql = context.getSQL();
				String countSql = context.getCountSQL();
				// conditions must be generated as getSQL method.
				String conditions = scContext.getConditionDefinition();
 * 
 * 
 */
public class SearchQueryGenerator {

	private static Logger logger = Logger.getLogger(SearchQueryGenerator.class);

	/* the search query definition */
	private SearchQueryType searchQueryDefinition;

	private String searchResultVarName;

	/* all query from list generated by the search from data definition */
	private List<String> queryFromList = new ArrayList<String>();

	/* all select field list generated by the search result mapping */
	private List<String> totalSelectFieldNameList = new ArrayList<String>();

	/*
	 * we use temporary variable to replace select field this is the mapping
	 * (Key: select field string, Value: temporary variable name)
	 */
	private Map<String, String> selectedFieldToVarMap = new HashMap<String, String>();

	/* the join filter generated by the link mapping of search query */
	private QueryExpressionNodeList joinConditionFilterExpression;

	/* search condition context */
	private SearchConditionContext searchConditionContext = null;

	/* the parsing context for parsing expression */
	private SearchQueryParsingContext totalParsingContext = new SearchQueryParsingContext();
	
	/* the search result mapping contexts.
	 */
	private List<SearchResultMappingContext> searchResultContextList = new ArrayList<SearchResultMappingContext>();

	/* Search query object */
	private SearchQuery basicQuery;
	
	public SearchQueryGenerator(SearchQueryType searchQueryDefinition)
			throws InvalidSearchQueryException {
		this.searchQueryDefinition = searchQueryDefinition;
		
		initSearchQuery();
	}

	/**
	 * init search query context
	 * 
	 * @throws InvalidSearchQueryException
	 */
	private void initSearchQuery() throws InvalidSearchQueryException {
		try {
			if (logger.isDebugEnabled()) {
				logger.debug("Start init search query at time:"
						+ System.currentTimeMillis());
			}

			// clear total parsing context
			totalParsingContext.removeAllVariables();

			// create search result parsing context
			VariableType searchResult = searchQueryDefinition.getSearchResult();
			searchResultVarName = searchResult.getName();
			Class searchResultClass = VariableUtil
					.getVariableClass(searchResult);
			totalParsingContext.setVariableClass(searchResultVarName,
					searchResultClass);
			totalParsingContext.setUseParamBinding(true);

			// create query from
			queryFromList.clear();
			List<SearchQueryType.FromData> fromData = searchQueryDefinition
					.getFromDatas();
			for (SearchQueryType.FromData fromDatum : fromData) {
				String name = fromDatum.getName();
				String custRDBName = fromDatum.getCustomerRDBName();
				TargetEntityType type = fromDatum.getType();
				String fromString = null;
				if (custRDBName != null && custRDBName.trim().length() != 0) {
					fromString = type.getEntityName() + "[" + custRDBName
							+ "] as " + name;
				} else {
					fromString = type.getEntityName() + " as " + name;
				}
				queryFromList.add(fromDatum.getCategory().toString() + " " + fromString);

				if (fromDatum.getCategory() == VariableCategoryType.JOIN_TABLE) {
					totalParsingContext.setVariableClass(name, JoinTableInstance.class);
				} else {
					Class fromDatumClass = VariableUtil.getVariableClass(fromDatum);
					totalParsingContext.setVariableClass(name, fromDatumClass);
				}
			}
			totalParsingContext.initSetVariable();

			// create join condition filter
			joinConditionFilterExpression = null;
			if (searchQueryDefinition.getLinkMapping() != null) {
				LinkConditionMappingType linkConditionMapping = searchQueryDefinition
						.getLinkMapping();
				/**
				List<ConditionFieldMappingType> linkConditionFieldMappings = linkConditionMapping
						.getFieldMapping();
				for (ConditionFieldMappingType mapping : linkConditionFieldMappings) {
					ISearchConditionFilter conditionFilter = SearchConditionFilterFactory
							.createSearchConditionFilter(mapping,
									totalParsingContext);
					QueryExpressionNodeList conditionExpression = conditionFilter
							.getStaticFilterExpression();
					joinConditionFilterExpression = SearchQueryUtil
							.appendExpressionNodeList(
									joinConditionFilterExpression,
									conditionExpression, LogicalOperator.AND);
				}
				*/
			}

			// create search condition filter
			SearchConditionMappingType conditionMapping = searchQueryDefinition
					.getSearchConditionMapping();
			searchConditionContext = new SearchConditionContext(
					conditionMapping, totalParsingContext,
					searchQueryDefinition.isIsDistinct());

			// create selection from
			searchResultContextList.clear();
			OQLFieldLister fieldLister = new OQLFieldLister();
			SearchResultMappingType searchResultMapping = searchQueryDefinition
					.getSearchResultMapping();
			List<SQLFieldMappingType> fieldMappings = searchResultMapping
					.getFieldMappings();
			for (SQLFieldMappingType mapping : fieldMappings) {
				SearchResultMappingContext searchResultContext = new SearchResultMappingContext(
						mapping, totalParsingContext);
				 //use field lister to collect all select field
				 //it also replace the select field with temporary variable
				searchResultContext.getSelectedFieldNames(fieldLister);
				searchResultContextList.add(searchResultContext);
			}

			// init field to temporary variable mapping
			selectedFieldToVarMap.clear();
			selectedFieldToVarMap.putAll(fieldLister
					.getFieldToVariableNameMap());

			// init all select from fields
			totalSelectFieldNameList.clear();
			Set<String> selectedFieldName = selectedFieldToVarMap.keySet();
			for (String name: selectedFieldName) {
				int index = name.indexOf(':');
				if (index != -1) {
					String alias = name.substring(0, index);
					String col = name.substring(index + 1).toUpperCase();
					totalSelectFieldNameList.add(alias + SQLConstants.DOT + col);
				} else {
					// overall fields mapping
					String beName = getBEName(name);
					String table = PersistentUtil.getTableName(beName);
					List<String> columns = PersistentUtil.getColumns(table);
					for (String col : columns) {
						totalSelectFieldNameList.add(name + SQLConstants.DOT + col.toUpperCase());
					}
				}
			}
			
			Map<String, List<?>> conditionObjects = new HashMap<String, List<?>>();
			conditionObjects.put("DefaultSearchCondition", 
					searchConditionContext.getDefaultConditionObjects());
			basicQuery = initBasicSearchQuery(conditionObjects);
			searchConditionContext.setSearchQuery(basicQuery);
			
			if (logger.isDebugEnabled())
				logger.debug("Finish init search query at time:"
						+ System.currentTimeMillis());
		} catch (Throwable t) {
			if (t instanceof InvalidSearchQueryException) {
				throw (InvalidSearchQueryException) t;
			} else {
				throw new InvalidSearchQueryException(
						"Error in initialize searchQuery: "
								+ searchQueryDefinition.getQueryName(), t);
			}
		}
	}
	
	/**
	 * get basic search query it contains select from fields, the query from,
	 * and link join filter
	 * 
	 * @return
	 * @throws PersistenceException
	 * @throws QueryParsingException 
	 */
	private SearchQuery initBasicSearchQuery(Map allSearchConditionObjects) 
			throws PersistenceException, QueryParsingException {
		if (queryFromList.size() == 0) {
			throw new PersistenceException("From table must be at least one.");
		}
		// set select from
		SearchQuery query = new SearchQuery(queryFromList.get(0), false, false);
		query.setDistinct(searchQueryDefinition.isIsDistinct());
		for (int i = 1, n = queryFromList.size(); i < n; i++) {
			queryFromList.get(i);
			query.addFrom(queryFromList.get(i));
		}

		// add link join filter
		if (joinConditionFilterExpression != null) {
			query.setJoinFilter(joinConditionFilterExpression);
		}

		// add time out parameter
		query.setTimeoutSeconds(searchQueryDefinition.getTimeoutSeconds());

		if (searchQueryDefinition.getOrderBies() != null) {
			List<OrderingType> orderingTypes = searchQueryDefinition
					.getOrderBies();
			for (OrderingType ordering : orderingTypes) {
				String orderByFieldName = ordering.getField();
				int index = orderByFieldName.indexOf('.');
				String alias = orderByFieldName.substring(0, index);
				String col = orderByFieldName.substring(index + 1).toUpperCase();
				query.addOrdering(new Ordering(alias + SQLConstants.DOT + col, 
						ordering.isIsAscending()));
			}
		}
		// set select field
		query.setSelection(totalSelectFieldNameList);
		
		QueryExpressionNodeList totalConditionFilter = null;
		for (Iterator it = allSearchConditionObjects.entrySet().iterator(); it
				.hasNext();) {
			Map.Entry entry = (Map.Entry) it.next();
			String conditionName = (String) entry.getKey();
			List conditionObjects = (List) entry.getValue();
			QueryExpressionNodeList conditionFilter = getSearchQuery(conditionObjects);
			totalConditionFilter = SearchQueryUtil.appendExpressionNodeList(
					totalConditionFilter, conditionFilter, LogicalOperator.OR);
		}

		QueryExpressionNodeList finalFilter = null;
		QueryExpressionNodeList filter = query.getFilter();
		finalFilter = SearchQueryUtil.appendExpressionNodeList(finalFilter,
				filter, LogicalOperator.AND);
		finalFilter = SearchQueryUtil.appendExpressionNodeList(finalFilter,
				totalConditionFilter, LogicalOperator.AND);
		query.setFilter(finalFilter);
		
		query.parse();
		
		return query;
	}
	
	/**
	 * get the search query filter for a search condition and the corresponding
	 * search condition objects
	 * 
	 * @param searchConditionName
	 * @param searchConditionObjects
	 * @return
	 * @throws PersistenceException
	 * @throws OQLException
	 */
	private QueryExpressionNodeList getSearchQuery(List<?> searchConditionObjects) throws PersistenceException {
		// find the search condition context and get query filter
		QueryExpressionNodeList searchConditionFilter = searchConditionContext
				.getSearchConditionFilter(searchConditionObjects);
		return searchConditionFilter;
	}
	
	public String getFromTableInfo() {
		StringBuffer sb = new StringBuffer();
		sb.append("        ArrayList<SQLTableInfo> tableInfo = new ArrayList<SQLTableInfo>();\n");
		List<SearchQueryType.FromData> fromData = searchQueryDefinition.getFromDatas();
		for (SearchQueryType.FromData var: fromData) {
			if (var.getCategory() == VariableCategoryType.JOIN_TABLE) {
				continue;
			}
			
			Class clazzType = VariableUtil.getVariableClass(var);
			sb.append("        addTableInfo(tableInfo, \"");
			sb.append(var.getName()).append("\", ");
			sb.append(clazzType.getName());
			sb.append(".class);\n");
		}
		return sb.toString();
	}
	
	public String getBEName(String varName) {
		List<SearchQueryType.FromData> fromData = searchQueryDefinition.getFromDatas();
		for (SearchQueryType.FromData var: fromData) {
			if (var.getCategory() == VariableCategoryType.BUSINESS_ENTITY) {
				if (varName.equals(var.getName())) {
					return var.getType().getEntityName();
				}
			}
		}
		return null;
	}

	public String getSQL() {
		try {
			return basicQuery.getSql();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return "Generate SQL Error!";
	}

	public String getCountSQL() {
		try {
			//count(1)
			return basicQuery.getCountSql();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return "Generate SQL Error!";
	}
	
	public String getReturnType() {
		return VariableUtil.getVariableClassName(searchQueryDefinition.getSearchResult());
	}

	public SearchConditionContext getSearchConditionContext() {
		return searchConditionContext;
	}
	
	/**
	 * @param searchConditionName
	 * @param searchConditionObjects
	 * @param validateObjectList
	 * @return
	 */
	public boolean validateSearchQueryResult(List<?> searchConditionObjects, Object validateObject)
			throws InvalidSearchQueryException {
		return searchConditionContext.validateSearchQueryResult(
				searchResultVarName, searchConditionObjects, validateObject);
	}

}
